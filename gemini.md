  IaC活用に関する要件定義書

  1. はじめに


  1.1. 背景
  本プロジェクトでは、AWS上に新規システムを構築する。構築するインフラの構成管理において、手作業による非効率性やヒューマンエラーを排除し、迅速かつ信頼性の高いインフラ提供を実現するため、Infrastructure as Code
  (IaC) のアプローチを全面的に採用する。


  1.2. 目的
  本ドキュメントは、本プロジェクトにおけるIaCの活用方針、技術選定、運用ルール、セキュリティ要件などを明確に定義し、関係者間の共通認識を形成することを目的とする。

  2. IaC導入のゴール
  IaC導入により、以下の実現を目指す。


   * 迅速性の向上: インフラ構築・変更プロセスの自動化によるリードタイムの短縮。
   * 信頼性・再現性の確保: コードに基づいたインフラ構成による、環境差異の撲滅と人的ミスの排除。
   * 可視性・追跡性の担保: Gitによるインフラ構成のバージョン管理と、変更履歴・レビュープロセスの可視化。
   * ガバナンスとセキュリティの強化: 静的コード解析とCI/CDパイプラインによる、セキュリティポリシーおよび品質基準の遵守。
   * コスト効率の改善: リソース構成の標準化と、不要リソースの特定・削除の容易化。


  3. 対象範囲 (スコープ)

  3.1. 対象AWSアカウント
   * 開発 (Development) 環境
   * ステージング (Staging) 環境
   * 本番 (Production) 環境


  3.2. 対象AWSサービス
  本プロジェクトで利用する以下のAWSリソースをIaCの管理対象とする。
  (※下記は例です。プロジェクトに応じて追記・削除してください)
   * ネットワーク: VPC, Subnet, Route Table, Security Group, NACL, NAT Gateway, Internet Gateway
   * コンピュート: EC2, Auto Scaling Group, ELB, Lambda, EKS/ECS
   * ストレージ: S3, EFS
   * データベース: RDS, ElastiCache, DynamoDB
   * IDとアクセス管理: IAM (User, Group, Role, Policy)
   * モニタリング: CloudWatch (Alarms, Logs), EventBridge
   * その他: Secrets Manager, SQS, SNS


  3.3. 対象外
   * AWSアカウントそのものの作成
   * OS、ミドルウェア、アプリケーションレイヤーの構成管理 (別途Ansible等の構成管理ツールで管理)
   * 緊急時のトラブルシューティングなど、やむを得ず実施する一時的な手動操作
   * S3バケット内のオブジェクトデータ

  4. 基本方針・原則


   * Everything as Code: 全てのAWSリソースはコードで定義し、AWSマネジメントコンソールからの手動変更は原則禁止とする。
   * Immutable Infrastructure (不変なインフラ): 稼働中のリソース（EC2インスタンス等）への直接的な構成変更は行わない。変更が必要な場合は、新しいリソースをコードから再構築し、古いリソースを破棄する。
   * Single Source of Truth (信頼できる唯一の情報源): Gitリポジトリをインフラ構成の唯一の正とし、コードと実際の環境の状態を常に一致させる。
   * レビュープロセスの徹底: 全ての構成変更は、Pull Request (Merge Request) を通じてレビュアーの承認を得ることを必須とする。
   * Dry Runの実施: インフラへの変更適用前には、必ずplanやdiff等のコマンドで影響範囲を事前確認する。

  5. 採用技術 (ツールスタック)


  | 領域             | 採用ツール          | 目的・理由                                                                                                                                   |
  | :--------------- | :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------- |
  | IaC言語          | Terraform           | HCLの宣言的な構文が可読性に優れ、AWS以外のマルチクラウドにも対応可能。豊富なプロバイダーとコミュニティによるエコシステムが成熟しているため。 |
  | バージョン管理   | Git (GitHub)        | コードのバージョン管理、変更履歴の追跡、およびPull Requestによるレビュープロセスの中核として利用。                                           |
  | CI/CD            | GitHub Actions      | GitHubと親和性が高く、Terraformのplan/applyの自動化や静的解析の組み込みが容易なため。                                                        |
  | 静的コード解析   | TFLint, tfsec       | TFLint: コーディング規約やベストプラクティスへの準拠をチェック。<br>tfsec: セキュリティ上の潜在的な脆弱性や設定ミスを早期に検知。            |
  | シークレット管理 | AWS Secrets Manager | DBのパスワードやAPIキー等の機密情報をコードから分離し、安全に管理するため。                                                                  |

  6. コード管理・リポジトリ戦略


  6.1. リポジトリ構成
   * 環境 (開発/ステージング/本番) ごとにディレクトリを分離した、単一のGitリポジトリ（モノレポ）で管理する。
   * ディレクトリ構成例:


    1     terraform-repo/
    2     ├── environments/
    3     │   ├── dev/
    4     │   │   └── main.tf
    5     │   ├── stg/
    6     │   │   └── main.tf
    7     │   └── prd/
    8     │       └── main.tf
    9     └── modules/
   10         ├── vpc/
   11         │   ├── main.tf
   12         │   └── variables.tf
   13         └── ec2/
   14             ├── main.tf
   15             └── variables.tf



  6.2. ブランチ戦略
   * GitHub Flow を採用する。
       * main: 常にデプロイ可能な状態を維持し、本番環境の状態と一致させる。直接のpushは禁止。
       * feature-branch: 機能追加や修正はmainからブランチを作成して行う。
   * mainブランチへのマージには、最低1名以上の承認済みレビューを必須とする。

  7. 実行環境・CI/CDパイプライン


  7.1. パイプライン設計
   * Pull Request作成時 (plan):
       1. terraform fmt -check (フォーマットチェック)
       2. terraform validate (構文チェック)
       3. tflint (静的解析)
       4. tfsec (セキュリティスキャン)
       5. terraform plan (実行計画の生成)
       6. 実行計画をPull Requestにコメントとして投稿
   * `main`ブランチへのマージ時 (apply):
       1. (ステージング環境) terraform apply を自動実行。
       2. (本番環境) GitHub Actionsの承認待ち機能を利用し、権限者の手動承認を経てterraform applyを実行。

  8. 状態管理 (State Management)


   * TerraformのStateファイル (terraform.tfstate) は、S3をリモートバックエンドとして利用し、チームで共有管理する。
   * Stateファイルへの同時書き込みによる破損を防ぐため、DynamoDBによるState Lockingを有効化する。
   * 環境ごと (dev/stg/prd)、および影響範囲の大きいコンポーネントごと (例: ネットワーク、アプリケーション基盤) にStateファイルを分割し、変更の影響範囲を限定する。


  9. セキュリティ要件


   * シークレットの分離: パスワードやAPIキー等の機密情報をTerraformコード内にハードコーディングすることを禁止する。AWS Secrets Manager等の外部サービスで管理し、データソースとして参照する。
   * 最小権限の原則: CI/CDパイプラインで利用するIAMロールには、Terraformの実行に必要な最小限の権限のみを付与する。
   * 静的解析の強制: CI/CDパイプラインにtfsecを組み込み、セキュリティリスクのあるコードがマージされることを防ぐ。
   * Drift Detection (構成ドリフト検知): コードと実環境の差分を検知するため、定期的にterraform planを実行し、差分があれば管理者に通知する仕組みを導入する。

  10. 命名規則・コーディング規約


   * リソース命名規則: プロジェクト名-環境名-リソース種別-通番 (例: myproj-prd-sg-01) のように、一貫性のある命名規則を別途定める。
   * コーディングスタイル:
       * terraform fmtによるコードフォーマットを必須とする。
       * 繰り返し利用するリソース群は積極的にモジュール化し、再利用性と保守性を高める。
       * 変数 (variables) と出力 (outputs) には、必ずdescriptionを記述する。

  11. 運用・保守


   * 緊急時対応: やむを得ず手動でインフラを変更した場合は、速やかにTerraformコードへ変更内容を反映 (Importまたはコード修正) し、差分がない状態に戻すこと。
   * バージョンアップ: Terraform本体およびプロバイダーのバージョンは、EOL(End-of-Life)を迎える前に計画的にアップグレードを実施する。
